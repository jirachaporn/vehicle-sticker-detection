



// import 'package:flutter/material.dart';
// import 'screens/sign_in_page.dart';
// import 'package:provider/provider.dart';
// import 'package:intl/date_symbol_data_local.dart';
// import 'providers/app_state.dart';
// import 'screens/main_screen.dart';
// import 'package:supabase_flutter/supabase_flutter.dart';
// import 'package:flutter_dotenv/flutter_dotenv.dart';

// void main() async {
//   WidgetsFlutterBinding.ensureInitialized();
//   await dotenv.load();
//   await initializeDateFormatting('en');

//   await Supabase.initialize(
//     url: dotenv.env['SUPABASE_URL']!,
//     anonKey: dotenv.env['SUPABASE_ANON_KEY']!,
//   );

//   await loginDevUser();

//   runApp(
//     ChangeNotifierProvider(create: (_) => AppState(), child: const MyApp()),
//   );
// }

// Future<void> loginDevUser() async {
//   final supabase = Supabase.instance.client;
//   final session = supabase.auth.currentSession;

//   if (session == null) {
//     final res = await supabase.auth.signInWithPassword(
//       email: 'vdowduang@gmail.com',
//       password: '123456789A.',
//     );

//     if (res.user != null) {
//       debugPrint('‚úÖ Dev login: ${res.user!.email}');
//     } else {
//       debugPrint('‚ùå Login failed: ${res.session?.accessToken}');
//     }
//   }
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       // debugShowCheckedModeBanner: false,
//       // title: 'Sign In Page',
//       // home: const SignInPage(),

//       title: 'Main Screen',
//       home: const MainScreen(
//         username: 'vdowduang',
//         email: 'vdowduang@gmail.com',
//         colorHex: '#AB47BC',
//       ),
//     );
//   }
// }

// import 'package:flutter/material.dart';
// import 'package:provider/provider.dart';
// import 'package:intl/date_symbol_data_local.dart';
// import 'package:supabase_flutter/supabase_flutter.dart';
// import 'package:flutter_dotenv/flutter_dotenv.dart';

// import 'providers/app_state.dart';
// import 'screens/main_page.dart';
// // import 'screens/sign_in_page.dart';

// void main() async {
//   WidgetsFlutterBinding.ensureInitialized();
//   await dotenv.load();
//   await initializeDateFormatting('en'); // ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ö‡∏ö dd/mm/yyyy

//   // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö supbase
//   await Supabase.initialize(
//     url: dotenv.env['SUPABASE_URL']!,
//     anonKey: dotenv.env['SUPABASE_ANON_KEY']!,
//   );

//   await loginDevUser(); 

//   runApp(
//     ChangeNotifierProvider(create: (_) => AppState(), child: const MyApp()),
//   );
// }

// Future<void> loginDevUser() async {
//   final supabase = Supabase.instance.client; // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
//   final session = supabase.auth.currentSession; // ‡∏ï‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö session ‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏¢ login ‡∏°‡∏±‡πâ‡∏¢

//   if (session == null) { // ‡πÑ‡∏°‡πà‡∏°‡∏µ session ‡πÄ‡∏Ç‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢ Dev password
//     final res = await supabase.auth.signInWithPassword(
//       email: 'vdowduang@gmail.com',
//       password: '123456789A.', 
//     );

//     if (res.user != null) { // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
//       debugPrint('‚úÖ Dev login: ${res.user!.email}');
//       await supabase.auth.refreshSession();
//     } else { // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
//       debugPrint('‚ùå Login failed: ${res.session?.accessToken}');
//     }
//   } else {
//     debugPrint('‚úÖ Already logged in: ${session.user.email}'); // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ session
//   }
// }

// class MyApp extends StatelessWidget {
//   const MyApp({super.key});

//   @override
//   Widget build(BuildContext context) {
//     final user = Supabase.instance.client.auth.currentUser; // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Ñ‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà

//     // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ login 
//     if (user == null) {
//       return const MaterialApp(
//         home: Scaffold(body: Center(child: Text('üîí ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡πà‡∏≠‡∏ô'))),
//       );
//     }
 
//     final meta = user.userMetadata ?? {};
//     debugPrint('üë§ user metadata: $meta');
//     final username = meta['username'] ?? 'Unknown';
//     final colorHex = meta['colorHex'] ?? '#4285F4';

//     return MaterialApp(
//       debugShowCheckedModeBanner: false,
//       title: 'Main Screen',
//       home: MainPage(
//         username: username,
//         email: user.email ?? '',
//         colorHex: colorHex,
//       ),
//     );
//   }
// }


































# def _try_open_camera():
#     """
#     ‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢ backend ‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö‡∏ö‡∏ô Windows:
#     1) CAP_DSHOW  2) CAP_MSMF  3) default
#     ‡πÅ‡∏•‡∏∞‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏ü‡∏£‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤ '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
#     """
#     backends = [cv2.CAP_DSHOW, cv2.CAP_MSMF, None]
#     for be in backends:
#         try:
#             cap = cv2.VideoCapture(0, be) if be is not None else cv2.VideoCapture(0)
#             if not cap.isOpened():
#                 try:
#                     cap.release()
#                 except:
#                     pass
#                 continue

#             # **‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏•‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏¥‡πâ‡∏á‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î**
#             for _ in range(10):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 6 ‡πÄ‡∏õ‡πá‡∏ô 10
#                 ret, _ = cap.read()
#                 if not ret:
#                     break

#             ok, img = cap.read()
#             if ok and img is not None and img.size > 0:
#                 return cap, be
#             cap.release()
#         except Exception as e:
#             print(f"‚ö†Ô∏è open camera with backend {be} failed: {e}")
#     return None, None







# --- ‡∏õ‡∏£‡∏±‡∏ö /start-camera ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á, ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• .pt ‡∏à‡∏≤‡∏Å Supabase Storage ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡πâ‡∏ß start worker ---
# @app.route("/start-camera", methods=["POST", "OPTIONS"])
# def start_camera():
#     if request.method == "OPTIONS":
#         return _corsify(make_response(("", 200)))

#     global camera, current_model, model_type, active_model_url
#     global detector_thread, detector_stop, current_location_id
#     global display_thread, display_stop
#     global latest_frame, latest_jpeg, latest_ts, latest_gen

#     data = request.get_json() or {}
#     location_id = data.get("location_id")
#     if not location_id:
#         return _corsify(jsonify({"error": "location_id is required"})), 400

#     # 1) ‡πÄ‡∏ä‡πá‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà active ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö location ‡∏ô‡∏µ‡πâ (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ is_active = TRUE ‡πÅ‡∏•‡∏∞‡∏°‡∏µ model_url)
#     try:
#         model_res = (
#             supabase.table("model")
#             .select("model_url")
#             .eq("location_id", location_id)
#             .eq("is_active", True)
#             .limit(1)
#             .execute()
#         )
#     except Exception as e:
#         return _corsify(jsonify({"error": f"DB error: {e}"})), 500

#     if not model_res.data or not (model_res.data[0].get("model_url") or "").strip():
#         # ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà
#         return _corsify(jsonify({
#             "error": "No active model for this location.",
#             "code": "NO_ACTIVE_MODEL"
#         })), 401

#     db_model_url = model_res.data[0]["model_url"].strip()

#     # 2) ‡∏õ‡∏¥‡∏î threads/‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô
#     try:
#         if display_thread and display_thread.is_alive():
#             display_stop.set()
#             display_thread.join(timeout=1)
#     except Exception:
#         pass
#     try:
#         if detector_thread and detector_thread.is_alive():
#             detector_stop.set()
#             detector_thread.join(timeout=1)
#     except Exception:
#         pass
#     try:
#         if camera is not None and camera.isOpened():
#             camera.release()
#     except Exception:
#         pass
#     time.sleep(0.1)

#     # 3) ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡∏°‡∏µ fallback ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô _try_open_camera)
#     cam, used_backend = _try_open_camera()
#     if cam is None:
#         return _corsify(jsonify({"error": "Unable to access webcam"})), 500
#     camera = cam

#     # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° 1280x720@60 ‡∏Å‡πà‡∏≠‡∏ô ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏•‡∏î‡πÄ‡∏õ‡πá‡∏ô 640x480@60)
#     camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
#     camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
#     camera.set(cv2.CAP_PROP_FPS, 60)
#     try:
#         actual_fps = camera.get(cv2.CAP_PROP_FPS) or 0
#     except Exception:
#         actual_fps = 0
#     if actual_fps < 59:
#         camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
#         camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
#         camera.set(cv2.CAP_PROP_FPS, 60)
#     for _ in range(8):
#         camera.read()

#     print(f"‚úÖ Camera opened, backend={used_backend}")

#     # 4) ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• .pt ‡∏à‡∏≤‡∏Å Supabase Storage ‚Üí ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ local (‡∏´‡πâ‡∏≤‡∏° Roboflow)
#     # active_model_url = None
#     # current_model = None
#     # model_type = None

#     # if torch is None:
#     #     return _corsify(jsonify({"error": "PyTorch is not available for local .pt"})), 500
#     # try:
#     #     with tempfile.NamedTemporaryFile(suffix=".pt", delete=False) as tmp:
#     #         urllib.request.urlretrieve(db_model_url, tmp.name)
#     #         current_model = torch.hub.load('ultralytics/yolov5', 'custom', path=tmp.name)
#     #     model_type = "local"
#     # except Exception as e:
#     #     return _corsify(jsonify({"error": f"Failed to download/load model: {e}"})), 500

#     # 5) ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏ü‡∏£‡∏° & ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å location ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
#     current_location_id = location_id
#     with latest_lock:
#         latest_frame = None
#         latest_jpeg = None
#         latest_ts = 0.0
#         latest_gen += 1

#     # 6) ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ï display worker
#     display_stop = threading.Event()
#     display_thread = threading.Thread(target=display_worker, daemon=True)
#     display_thread.start()

#     # 7) ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ï detection worker
#     detector_stop = threading.Event()
#     detector_thread = threading.Thread(target=detection_worker, daemon=True)
#     detector_thread.start()

#     return _corsify(jsonify({
#         "message": "Camera started",
#         "model_type": model_type,          # "local"
#         "location_id": current_location_id,
#         "generation": latest_gen
#     })), 200













// lib/pages/permission_page.dart
// ===== import =====
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_dotenv/flutter_dotenv.dart';

import '../providers/permission_provider.dart';
import '../models/permission.dart';

// Tabs
import '../widgets/permission/members_tab.dart';
import '../widgets/permission/invite_tab.dart';
import '../widgets/permission/logs_tab.dart';
import '../widgets/permission/dialogs.dart';

// ===== class =====
class PermissionPage extends StatefulWidget {
  final String locationId;
  final String? locationName;

  const PermissionPage({
    super.key,
    required this.locationId,
    this.locationName,
  });

  @override
  State<PermissionPage> createState() => _PermissionPageState();
}

// ===== ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£/‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏ô class =====
class _PermissionPageState extends State<PermissionPage>
    with SingleTickerProviderStateMixin {
  // --- state ---
  late TabController tab;
  final inviteEmailCtrl = TextEditingController();
  final inviteNameCtrl = TextEditingController();
  String invitePerm = 'view';
  bool loading = false;
  bool loadingInvite = false;

  // --- life cycle ---
  @override
  void initState() {
    super.initState();
    tab = TabController(length: 3, vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) => refreshAll());
  }

  @override
  void dispose() {
    tab.dispose();
    inviteEmailCtrl.dispose();
    inviteNameCtrl.dispose();
    super.dispose();
  }

  // --- actions ---
  Future<void> refreshAll() async {
    if (!mounted) return;
    setState(() => loading = true);
    try {
      await context.read<PermissionProvider>().loadMembers(widget.locationId);
    } finally {
      if (mounted) setState(() => loading = false);
    }
  }

  Future<void> handleInvite() async {
    final provider = context.read<PermissionProvider>();

    // raw ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• / email ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö DB
    final rawEmail = inviteEmailCtrl.text.trim();
    final email = rawEmail.toLowerCase();
    final name = inviteNameCtrl.text.trim();

    // 0) ‡∏ï‡∏£‡∏ß‡∏à‡∏≠‡∏µ‡πÄ‡∏°‡∏•
    if (!isEmail(rawEmail)) {
      toast(context, 'Please enter a valid email');
      return;
    }

    setState(() => loadingInvite = true);

    try {
      // 1) ‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ invited
      final permType = PermissionTypeX.fromDb(invitePerm); 
      await provider.upsertMember(
        locationId: widget.locationId,
        email: email, 
        name: name.isEmpty ? null : name,
        permission: permType,
        status: MemberStatus.invited,
      );

      // 2) ‡∏Ç‡∏≠ token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô (‡πÉ‡∏´‡πâ provider.invite ‡∏™‡∏£‡πâ‡∏≤‡∏á base64url)
      final token = await provider.invite(
        locationId: widget.locationId,
        inviteEmail: email, // lower-case
        permission: invitePerm.toLowerCase(), // 'view' | 'edit' | 'owner'
        inviteName: name.isEmpty ? null : name,
      );

      // 3) ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô (encode token ‡∏Å‡∏±‡∏ô‡∏≠‡∏±‡∏Å‡∏Ç‡∏£‡∏∞‡∏û‡∏¥‡πÄ‡∏®‡∏©)
      final baseUrlRaw = dotenv.env['SUPABASE_URL'] ?? '';
      final baseUrl = baseUrlRaw.replaceAll(RegExp(r'/$'), '');
      final encodedToken = Uri.encodeComponent(token);
      final confirmLink =
          '$baseUrl/functions/v1/confirm-permission?token=$encodedToken';

      // 4) ‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÄ‡∏ä‡∏¥‡∏ç
      await sendInviteEmail(
        toEmail: rawEmail, // ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏Å
        linkUrl: confirmLink,
        invitedName: name,
        locationName: widget.locationName,
      );

      // 5) ‡πÅ‡∏à‡πâ‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à + ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå
      if (!mounted) return;
      await copyToClipboardAndDialogSuccess(
        context,
        title: 'Invite sent successfully! üéâ',
        message:
            'Invitation link has been sent to $rawEmail\n\nLink: $confirmLink',
        copyText: confirmLink,
      );

      // 6) ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏ü‡∏≠‡∏£‡πå‡∏°
      inviteEmailCtrl.clear();
      inviteNameCtrl.clear();
      setState(() => invitePerm = 'view');

      // 7) ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠
      await provider.loadMembers(widget.locationId);
    } catch (e, st) {
      debugPrint('[handleInvite] error: $e\n$st');
      if (!mounted) return;
      toast(context, 'Failed to invite: ${e.toString()}');
    } finally {
      if (mounted) setState(() => loadingInvite = false);
    }
  }

  Future<void> handleExpireSweep() async {
    toast(
      context,
      'Expired invitation sweep is not supported in this version',
    );
  }

  // ----- helpers -----
  Future<void> sendInviteEmail({
    required String toEmail,
    required String linkUrl,
    String? invitedName,
    String? locationName,
  }) async {
    // ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô backend ‡∏à‡∏£‡∏¥‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    final endpoint = Uri.parse('http://127.0.0.1:5000/send-permission-email');

    final res = await http.post(
      endpoint,
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'to_email': toEmail,
        'link_url': linkUrl,
        'invited_name': invitedName ?? '',
        'location_name': locationName ?? 'Unknown',
        'subject': 'Confirm access to ${locationName ?? ''}'.trim(),
      }),
    );

    if (res.statusCode != 200) {
      throw Exception('Failed to send email: ${res.body}');
    }
  }

  bool isEmail(String v) {
    final re = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
    return re.hasMatch(v);
  }

  void toast(BuildContext context, String msg) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  // ===== Widget ‡∏´‡∏•‡∏±‡∏Å =====
  @override
  Widget build(BuildContext context) {
    final title = widget.locationName ?? 'Permissions';

    return Scaffold(
      backgroundColor: const Color(0xFFF7F8FA),
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.white,
        foregroundColor: Colors.black87,
        title: Text(
          title,
          style: const TextStyle(fontSize: 20, fontWeight: FontWeight.w700),
        ),
        bottom: TabBar(
          controller: tab,
          indicatorColor: const Color(0xFF2563EB),
          labelColor: const Color(0xFF2563EB),
          unselectedLabelColor: Colors.black54,
          tabs: const [
            Tab(text: 'Members'),
            Tab(text: 'Invite'),
            Tab(text: 'Logs'),
          ],
        ),
      ),
      body: loading
          ? const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF2563EB)),
              ),
            )
          : TabBarView(
              controller: tab,
              children: [
                // ===== Widget ‡∏¢‡πà‡∏≠‡∏¢ =====
                MembersTab(
                  locationId: widget.locationId,
                  onChanged: refreshAll,
                ),
                InviteTab(
                  locationId: widget.locationId,
                  inviteEmailCtrl: inviteEmailCtrl,
                  inviteNameCtrl: inviteNameCtrl,
                  invitePerm: invitePerm,
                  onPermChanged: (v) => setState(() => invitePerm = v),
                  loading: loadingInvite,
                  onSubmit: handleInvite,
                ),
                LogsTab(
                  locationId: widget.locationId,
                  onExpireSweep: handleExpireSweep,
                ),
              ],
            ),
    );
  }
}
